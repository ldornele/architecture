# HyperFleet Adapter Framework Configuration Template (MVP)
#
# This is a Configuration Template for configuring cloud provider adapters
# using the HyperFleet Adapter Framework with CEL (Common Expression Language).
#
# TEMPLATE SYNTAX:
# ================
# 1. Go Templates ({{ .var }}) - Variable interpolation throughout
# 2. field: "path" - Simple JSON path extraction (translated to CEL internally)
# 3. expression: "cel" - Full CEL expressions for complex logic
# ============================================================================
# CEL OPTIONAL CHAINING:
# ======================
# Use optional chaining with orValue() to safely access potentially missing fields:
#   resources.?clusterNamespace.?status.?phase.orValue("")
#   adapter.?executionStatus.orValue("")
#
# Copy this file to your adapter repository and customize for your needs.

# ============================================================================
# Global params
# ============================================================================
# params to extract from CloudEvent and environment variables
params:
  # Environment variables from deployment
  - name: "hyperfleetApiBaseUrl"
    source: "config.hyperfleetApiBaseUrl"
    type: "string"
    description: "Base URL for the HyperFleet API"
    required: true
  
  - name: "hyperfleetApiVersion"
    source: "config.hyperfleetApiVersion"
    type: "string"
    default: "v1"
    description: "API version to use"
  
  # Extract from CloudEvent data
  - name: "clusterId"
    source: "event.id"
    type: "string"
    description: "Unique identifier for the target cluster"
    required: true


# ============================================================================
# Global Preconditions
# ============================================================================
# These preconditions run sequentially and validate cluster state before resource operations
preconditions:
  # ==========================================================================
  # Step 1: Get cluster status
  # ==========================================================================
  - name: "clusterStatus"
    apiCall:
      method: "GET"
      # NOTE: API path includes /api/hyperfleet/ prefix
      url: "{{ .hyperfleetApiBaseUrl }}/api/hyperfleet/{{ .hyperfleetApiVersion }}/clusters/{{ .clusterId }}"
      timeout: 10s
      retryAttempts: 3
      retryBackoff: "exponential"
    # Capture fields from the API response. Captured values become variables for use in resources section.
    capture:
      - name: "clusterName"
        field: "name"
      - name: "generationId"
        field: "generation"
      - name: "placementClusterName"
        field: "status.conditions.placement.data.clusterName" # This is an example how to capture placement cluster name from the cluster status
      - name: "namespaceName"
        field: "conditions.landingzone.data.namespace.name"
    conditions:
      - field: "namespaceName"
        operator: "notExists"

# ============================================================================
# Resources (Create/Update Resources)
# ============================================================================
# All resources are created/updated sequentially in the order defined below
resources:
  # ==========================================================================
  # Resource 1: Cluster Namespace
  # ==========================================================================
  - name: "clusterNamespace"
    transport:
      client: "kubernetes"
    manifests:
      - name: "clusterNamespace"
        manifest:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ .clusterId | lower }}"
            labels:
              hyperfleet.io/cluster-id: "{{ .clusterId }}"
              hyperfleet.io/managed-by: "{{ .metadata.name }}"
              hyperfleet.io/resource-type: "namespace"
            annotations:
              hyperfleet.io/managed-by: "{{ .metadata.name }}"
              hyperfleet.io/generation: "{{ .generationId }}"
        discovery:
          # The "namespace" field within discovery is optional:
          # - For namespaced resources: set namespace to target the specific namespace
          # - For cluster-scoped resources (like Namespace, ClusterRole): omit or leave empty
          # Here we omit it since Namespace is cluster-scoped
          bySelectors:
            labelSelector:
              hyperfleet.io/resource-type: "namespace"
              hyperfleet.io/cluster-id: "{{ .clusterId }}"
              hyperfleet.io/managed-by: "{{ .metadata.name }}"
  - name: "agentNamespaceManifestWork"
    transport:
      client: "maestro"
      maestro:
        targetCluster: "{{ .placementClusterName }}"
        # manifestWork supports both inline configuration and and ref approaches
        # ref is suggested as the file method is more readable and maintainable.
        manifestWork:
          ref: "./manifestwork-ref.yaml"
          # apiVersion: work.open-cluster-management.io/v1
          # kind: ManifestWork
          # metadata:
          #   PUTYOURMETADATAHERE
          # spec:
          #   workload:
          #     manifests: {{ .resources.agentNamespaceManifestWork.manifests | toJson }}
          #   deleteOption:
          #     propagationPolicy: "Foreground"
          #     gracePeriodSeconds: 30
          #   manifestConfigs:
          #     - resourceIdentifier:
          #         group: "v1"
          #         resource: "namespaces"
          #         name: "{{ .clusterId | lower }}"
    manifests:
      - name: "agentNamespace"
        # below manifest can be rendered from a template file, or just inline as below
        # Optionally, you can nested it to the manifestWork ref template to avoid maintain outside of manifestWork template
        manifest:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ .clusterId | lower }}"
            labels:
              hyperfleet.io/cluster-id: "{{ .clusterId }}"
              hyperfleet.io/managed-by: "{{ .metadata.name }}"
              hyperfleet.io/resource-type: "namespace"
            annotations:
              hyperfleet.io/created-by: "hyperfleet-adapter"
              hyperfleet.io/generation: "{{ .generationId }}"
        discovery:
          # The "namespace" field within discovery is optional:
          # - For namespaced resources: set namespace to target the specific namespace
          # - For cluster-scoped resources (like Namespace, ClusterRole): omit or leave empty
          # Here we omit it since Namespace is cluster-scoped
          bySelectors:
            labelSelector:
              hyperfleet.io/resource-type: "namespace"
              hyperfleet.io/cluster-id: "{{ .clusterId }}"
              hyperfleet.io/managed-by: "{{ .metadata.name }}"


# ============================================================================
# Post-Processing
# ============================================================================
post:
  payloads:
    # Build status payload inline
    - name: "clusterStatusPayload"
      build:
        # Adapter name for tracking which adapter reported this status
        adapter: "{{ .metadata.name }}"
        
        # Conditions array - each condition has type, status, reason, message
        # Use CEL optional chaining ?.orValue() for safe field access
        conditions:
          # Applied: Resources successfully created
          - type: "Applied"
            status:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active" ? "True" : "False"
            reason:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active"
                  ? "NamespaceCreated"
                  : "NamespacePending"
            message:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active"
                  ? "Namespace created successfully"
                  : "Namespace creation in progress"

          # Available: Resources are active and ready
          - type: "Available"
            status:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active" ? "True" : "False"
            reason:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active" ? "NamespaceReady" : "NamespaceNotReady"
            message:
              expression: |
                resources.?agentNamespaceManifestWork.agentNamespace.?status.?phase.orValue("") == "Active" ? "Namespace is active and ready" : "Namespace is not active and ready"

          # Health: Adapter execution status (runtime) Don't need to update this. This can be reused from the adapter config.
          - type: "Health"
            status:
              expression: |
                adapter.?executionStatus.orValue("") == "success" ? "True" : (adapter.?executionStatus.orValue("") == "failed" ? "False" : "Unknown")
            reason:
              expression: |
                adapter.?errorReason.orValue("") != "" ? adapter.?errorReason.orValue("") : "Healthy"
            message:
              expression: |
                adapter.?errorMessage.orValue("") != "" ? adapter.?errorMessage.orValue("") : "All adapter operations completed successfully"
        
        # Use CEL expression for numeric fields to preserve type (not Go template which outputs strings)
        observed_generation:
          expression: "generationId"
          
        # Use Go template with now and date functions for timestamps
        observed_time:
          value: "{{ now | date \"2006-01-02T15:04:05Z07:00\" }}"

        # Optional data field for adapter-specific metrics extracted from resources
        data:
          namespace:
            name:
              expression: |
                resources.?clusterNamespace.?metadata.?name.orValue("")
            status:
              expression: |
                resources.?clusterNamespace.?status.?phase.orValue("")

  # ==========================================================================
  # Post Actions
  # ==========================================================================
  # Post actions are executed after resources are created/updated
  postActions:
    # Report cluster status to HyperFleet API (always executed)
    - name: "reportClusterStatus"
      apiCall:
        method: "POST"
        # NOTE: API path includes /api/hyperfleet/ prefix and ends with /statuses
        url: "{{ .hyperfleetApiBaseUrl }}/api/hyperfleet/{{ .hyperfleetApiVersion }}/clusters/{{ .clusterId }}/statuses"
        body: "{{ .clusterStatusPayload }}"
        timeout: 30s
        retryAttempts: 3
        retryBackoff: "exponential"
        headers:
          - name: "Content-Type"
            value: "application/json"
